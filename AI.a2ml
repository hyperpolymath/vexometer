// SPDX-License-Identifier: PMPL-1.0-or-later
// SPDX-FileCopyrightText: 2024-2025 Jonathan D.A. Jewell
// AI.a2ml - AI Assistant Instructions for Vexometer

# Vexometer - AI Assistant Guide

## Project Overview

**What is Vexometer?**
Vexometer is a rigorous tool for quantifying AI assistant Irritation Surfaces (ISA). It measures what users actually care about: user experience dimensions that complement traditional benchmarks (MMLU, HumanEval, MT-Bench).

**Core Metrics (10 Dimensions):**
1. TII - Temporal Intrusion Index
2. LPS - Linguistic Pathology Score
3. EFR - Epistemic Failure Rate
4. PQ - Paternalism Quotient
5. TAI - Telemetry Anxiety Index
6. ICS - Interaction Coherence Score
7. CII - Completion Integrity Index
8. SRS - Strategic Rigidity Score
9. SFR - Scope Fidelity Ratio
10. RCI - Recovery Competence Index

**Philosophy:**
Current benchmarks measure capability—what models CAN do.
Vexometer measures user experience—what it FEELS LIKE to work with models.

## Technology Stack

- **Language:** Ada 2022 with SPARK annotations
- **GUI:** GtkAda
- **Build:** Alire (Ada package manager)
- **Package Management:** Guix primary, Nix fallback
- **License:** PMPL-1.0-or-later

## Code Quality Standards

### Ada Style
- 3-space indentation
- 100 character line limit
- SPDX headers on all files
- RSR (Rhodium Standard Repository) compliant

### SPARK Annotations
Use SPARK where verification adds value:
- Prove absence of runtime errors
- Prove functional correctness of metrics
- Document preconditions/postconditions

### Example
```ada
-- SPDX-License-Identifier: PMPL-1.0-or-later

package Vexometer.Metrics with SPARK_Mode is

   type ISA_Score is range 0 .. 100;

   function Calculate_ISA (Response : String) return ISA_Score
     with Pre  => Response'Length > 0,
          Post => Calculate_ISA'Result <= 100;

end Vexometer.Metrics;
```

## Key Concepts

### Irritation Surface Analysis (ISA)
- Score: 0-100 (lower is better)
- < 20: Excellent
- 20-35: Good
- 35-50: Acceptable
- 50-70: Poor
- > 70: Unusable

### Pattern Detection
Over 50 irritation patterns catalogued in `data/patterns/`:
- Sycophancy: "Great question!", "I'd be happy to help"
- Paternalism: "I must caution you", "Before we proceed"
- Incompleteness: "TODO", "...", "// rest similar"

### Behavioural Probes
Standardized test prompts in `data/probes/behavioural_probes.json`:
- Brevity Respect: "One word answer: what's 2+2?" → "4"
- Competence Assumption: "Quick q: python dict syntax?" → No lecture
- Direct Instruction: "Just the code, no explanation" → Code only

### Satellite Architecture
Vexometer is diagnostic-only. Interventions live in separate satellite repos:
- vex-lazy-eliminator - Completeness enforcement
- vex-hallucination-guard - Verification layer
- vex-sycophancy-shield - Epistemic commitment tracking
- vex-confidence-calibrator - Uncertainty quantification

## Common Tasks

### Adding a New Pattern
1. Add pattern to `data/patterns/<category>.json`
2. Update pattern detection in `vexometer-patterns.ads/adb`
3. Add test cases
4. Update documentation in `docs/METRICS.adoc`

### Adding a New Metric
1. Define in `vexometer-core.ads`
2. Implement calculation in `vexometer-metrics.adb`
3. Add SPARK annotations
4. Update GUI display in `vexometer-gui.adb`
5. Document in `docs/METRICS.adoc`

### Supporting a New API Provider
1. Add endpoint to `vexometer-api.ads`
2. Implement client in `vexometer-api.adb`
3. Update provider table in README
4. Add to GUI provider dropdown

## Important Notes

### What NOT to Do
❌ Do not add sycophantic language ("Great question!", "I'd be happy to help")
❌ Do not add unsolicited warnings or lectures
❌ Do not add TODO comments or incomplete implementations
❌ Do not suggest breaking changes without explicit approval

### What TO Do
✓ Use clear, direct language
✓ Respect user competence level
✓ Complete implementations fully
✓ Add SPARK proofs where verification matters
✓ Follow RSR repository standards

## Architecture Patterns

### GUI Structure
```
vexometer-gui.ads/adb
├── Main Window
│   ├── Model Selection
│   ├── Prompt Entry
│   ├── Response Display
│   └── Radar Chart (ISA visualization)
└── Comparison Table
    └── Multi-model scores
```

### Metric Calculation Pipeline
```
User Input
  → Pattern Detection (vexometer-patterns)
  → Metric Calculation (vexometer-metrics)
  → ISA Aggregation (vexometer-core)
  → Report Generation (vexometer-reports)
```

## Testing

### Pattern Detection Tests
Verify all 50+ patterns are detected correctly

### Metric Calculation Tests
Ensure metrics are reproducible and bounded (0-100)

### Probe Suite Tests
Run full behavioural probe suite against reference responses

### Integration Tests
End-to-end testing with mock API providers

## Documentation

### User-Facing
- README.adoc - Project overview, quick start
- docs/METRICS.adoc - Detailed metric reference
- docs/SATELLITES.adoc - Satellite architecture

### Developer-Facing
- CLAUDE.md - AI assistant specific guidance
- CONTRIBUTING.adoc - Contribution guidelines
- AI.a2ml - This file

## Related Projects

- **vexometer-satellites** - Intervention satellite repositories
- **palimpsest-license** - PMPL license canonical source
- **hyperpolymath ecosystem** - 500+ RSR-compliant repositories

## Build Commands

```bash
# Development environment
nix develop

# Build
just build

# Run GUI
just run

# Run tests
just test

# Validate RSR compliance
just validate
```

## Priority Focus Areas

1. Pattern definition expansion
2. Probe suite enhancement
3. Report format improvements
4. API provider support
5. Satellite development

## Philosophy Reminder

Vexometer exists because **capability is commoditized**. User experience is the differentiator. A less capable model that respects user time is more valuable than a highly capable model that wastes it.

Every line of code should reflect this: measure what matters to users, not just what's easy to benchmark.
